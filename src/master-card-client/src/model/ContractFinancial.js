/**
 * Mastercard Processing Core API
 * OpenAPI Specification for MP (Mastercard Processing) **Core**.  This documentation describes what functionalities are exposed by the MP's CMS (Card Management System) and are available to be used by the Issuer. The Issuer is the primary actor who executes the operations. Whenever the Issuer wishes to onboard its customers to the card program, they may use API to:  * create and manage **client**  * create and manage **contracts**, there are two types of contracts in the MP's CMS:    * **account contract**    * **card contract**  Later, during the card lifecycle, the Issuer can also manage other objects related to the client and the contract (account or card):  * manage **card plastic**  * create, manage and retrieve **additional addresses** (for the client and the contract)  * manage and retrieve **classifiers** (for the client and the contract)  * manage and retrieve **custom data** (for the client and the contract)  * manage and retrieve **parameters** (for the contract)  * set or retrieve **service limit tariff** (for the contract)  * post or retrieve **transactions** (for the contract)  * manage and retrieve **usage limits** (for the contract)  *** API uses RESTful protocol via HTTP to execute POST, PUT, GET and PATCH operations sent to given endpoints, e.g. `/clients`.  API uses JSON Web Encryption compact serialization for payload encryption for all API operations. *** External documentation:   * [ISO 4217 - Currency Codes](https://www.iso.org/iso-4217-currency-codes.html)   * [ISO 3166 - Country Codes](https://www.iso.org/iso-3166-country-codes.html)   * [Internet Engineering Task Force (IETF) BCP 47 standard](https://tools.ietf.org/html/bcp47#appendix-A)   * [JSON Web Encryption](https://developer.mastercard.com/platform/documentation/security-and-authentication/securing-sensitive-data-using-payload-encryption/#jwe-encryption)   * [Internet Engineering Task Force (IETF) RFC7232](https://datatracker.ietf.org/doc/html/rfc7232)   * [JSON Merge Patch](https://datatracker.ietf.org/doc/html/rfc7386) *** 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: apisupport@mastercard.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The ContractFinancial model module.
 * @module model/ContractFinancial
 * @version 1.0.0
 */
class ContractFinancial {
    /**
     * Constructs a new <code>ContractFinancial</code>.
     * @alias module:model/ContractFinancial
     * @param amendmentDate {Date} Date and time of the most recent change to the object (YYYY-MM-DDThh:mm:ssZ format). 
     * @param clientId {Number} A unique technical client identifier, generated by the MP's CMS database engine. The identifier is generated when client creation is completed successfully and is returned in a client creation response (`POST /clients`). 
     * @param contractId {Number} Contract record id from MP's CMS database. 
     * @param currency {String} Currency of the due amount (format according to ISO 4217, alphanumeric code). 
     */
    constructor(amendmentDate, clientId, contractId, currency) { 
        
        ContractFinancial.initialize(this, amendmentDate, clientId, contractId, currency);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, amendmentDate, clientId, contractId, currency) { 
        obj['amendmentDate'] = amendmentDate;
        obj['clientId'] = clientId;
        obj['contractId'] = contractId;
        obj['currency'] = currency;
    }

    /**
     * Constructs a <code>ContractFinancial</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/ContractFinancial} obj Optional instance to populate.
     * @return {module:model/ContractFinancial} The populated <code>ContractFinancial</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new ContractFinancial();

            if (data.hasOwnProperty('additionalCreditLimit')) {
                obj['additionalCreditLimit'] = ApiClient.convertToType(data['additionalCreditLimit'], 'Number');
            }
            if (data.hasOwnProperty('additionalCreditLimitEffectiveDate')) {
                obj['additionalCreditLimitEffectiveDate'] = ApiClient.convertToType(data['additionalCreditLimitEffectiveDate'], 'Date');
            }
            if (data.hasOwnProperty('additionalCreditLimitExpiryDate')) {
                obj['additionalCreditLimitExpiryDate'] = ApiClient.convertToType(data['additionalCreditLimitExpiryDate'], 'Date');
            }
            if (data.hasOwnProperty('amendmentDate')) {
                obj['amendmentDate'] = ApiClient.convertToType(data['amendmentDate'], 'Date');
            }
            if (data.hasOwnProperty('availableAmount')) {
                obj['availableAmount'] = ApiClient.convertToType(data['availableAmount'], 'Number');
            }
            if (data.hasOwnProperty('balance')) {
                obj['balance'] = ApiClient.convertToType(data['balance'], 'Number');
            }
            if (data.hasOwnProperty('blockedAmount')) {
                obj['blockedAmount'] = ApiClient.convertToType(data['blockedAmount'], 'Number');
            }
            if (data.hasOwnProperty('clientId')) {
                obj['clientId'] = ApiClient.convertToType(data['clientId'], 'Number');
            }
            if (data.hasOwnProperty('contractId')) {
                obj['contractId'] = ApiClient.convertToType(data['contractId'], 'Number');
            }
            if (data.hasOwnProperty('creditLimit')) {
                obj['creditLimit'] = ApiClient.convertToType(data['creditLimit'], 'Number');
            }
            if (data.hasOwnProperty('creditLimitEffectiveDate')) {
                obj['creditLimitEffectiveDate'] = ApiClient.convertToType(data['creditLimitEffectiveDate'], 'Date');
            }
            if (data.hasOwnProperty('currency')) {
                obj['currency'] = ApiClient.convertToType(data['currency'], 'String');
            }
            if (data.hasOwnProperty('currencyNumericCode')) {
                obj['currencyNumericCode'] = ApiClient.convertToType(data['currencyNumericCode'], 'String');
            }
            if (data.hasOwnProperty('currentDueAmount')) {
                obj['currentDueAmount'] = ApiClient.convertToType(data['currentDueAmount'], 'Number');
            }
            if (data.hasOwnProperty('delinquencyHistory')) {
                obj['delinquencyHistory'] = ApiClient.convertToType(data['delinquencyHistory'], 'String');
            }
            if (data.hasOwnProperty('disputeAmount')) {
                obj['disputeAmount'] = ApiClient.convertToType(data['disputeAmount'], 'Number');
            }
            if (data.hasOwnProperty('dueDate')) {
                obj['dueDate'] = ApiClient.convertToType(data['dueDate'], 'Date');
            }
            if (data.hasOwnProperty('graceDate')) {
                obj['graceDate'] = ApiClient.convertToType(data['graceDate'], 'Date');
            }
            if (data.hasOwnProperty('lastPaymentAmount')) {
                obj['lastPaymentAmount'] = ApiClient.convertToType(data['lastPaymentAmount'], 'Number');
            }
            if (data.hasOwnProperty('lastPaymentDate')) {
                obj['lastPaymentDate'] = ApiClient.convertToType(data['lastPaymentDate'], 'Date');
            }
            if (data.hasOwnProperty('mainContractId')) {
                obj['mainContractId'] = ApiClient.convertToType(data['mainContractId'], 'Number');
            }
            if (data.hasOwnProperty('mainContractNumber')) {
                obj['mainContractNumber'] = ApiClient.convertToType(data['mainContractNumber'], 'String');
            }
            if (data.hasOwnProperty('overlimitAmount')) {
                obj['overlimitAmount'] = ApiClient.convertToType(data['overlimitAmount'], 'Number');
            }
            if (data.hasOwnProperty('parentContractId')) {
                obj['parentContractId'] = ApiClient.convertToType(data['parentContractId'], 'Number');
            }
            if (data.hasOwnProperty('parentContractNumber')) {
                obj['parentContractNumber'] = ApiClient.convertToType(data['parentContractNumber'], 'String');
            }
            if (data.hasOwnProperty('pastDueAmount')) {
                obj['pastDueAmount'] = ApiClient.convertToType(data['pastDueAmount'], 'Number');
            }
            if (data.hasOwnProperty('pastDueDate')) {
                obj['pastDueDate'] = ApiClient.convertToType(data['pastDueDate'], 'Date');
            }
            if (data.hasOwnProperty('pastDueDays')) {
                obj['pastDueDays'] = ApiClient.convertToType(data['pastDueDays'], 'Number');
            }
            if (data.hasOwnProperty('previousCreditLimit')) {
                obj['previousCreditLimit'] = ApiClient.convertToType(data['previousCreditLimit'], 'Number');
            }
            if (data.hasOwnProperty('previousCreditLimitEffectiveDate')) {
                obj['previousCreditLimitEffectiveDate'] = ApiClient.convertToType(data['previousCreditLimitEffectiveDate'], 'Date');
            }
            if (data.hasOwnProperty('temporaryCreditLimit')) {
                obj['temporaryCreditLimit'] = ApiClient.convertToType(data['temporaryCreditLimit'], 'Number');
            }
            if (data.hasOwnProperty('temporaryCreditLimitEffectiveDate')) {
                obj['temporaryCreditLimitEffectiveDate'] = ApiClient.convertToType(data['temporaryCreditLimitEffectiveDate'], 'Date');
            }
            if (data.hasOwnProperty('temporaryCreditLimitExpiryDate')) {
                obj['temporaryCreditLimitExpiryDate'] = ApiClient.convertToType(data['temporaryCreditLimitExpiryDate'], 'Date');
            }
            if (data.hasOwnProperty('totalDueAmount')) {
                obj['totalDueAmount'] = ApiClient.convertToType(data['totalDueAmount'], 'Number');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>ContractFinancial</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>ContractFinancial</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of ContractFinancial.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['currency'] && !(typeof data['currency'] === 'string' || data['currency'] instanceof String)) {
            throw new Error("Expected the field `currency` to be a primitive type in the JSON string but got " + data['currency']);
        }
        // ensure the json data is a string
        if (data['currencyNumericCode'] && !(typeof data['currencyNumericCode'] === 'string' || data['currencyNumericCode'] instanceof String)) {
            throw new Error("Expected the field `currencyNumericCode` to be a primitive type in the JSON string but got " + data['currencyNumericCode']);
        }
        // ensure the json data is a string
        if (data['delinquencyHistory'] && !(typeof data['delinquencyHistory'] === 'string' || data['delinquencyHistory'] instanceof String)) {
            throw new Error("Expected the field `delinquencyHistory` to be a primitive type in the JSON string but got " + data['delinquencyHistory']);
        }
        // ensure the json data is a string
        if (data['mainContractNumber'] && !(typeof data['mainContractNumber'] === 'string' || data['mainContractNumber'] instanceof String)) {
            throw new Error("Expected the field `mainContractNumber` to be a primitive type in the JSON string but got " + data['mainContractNumber']);
        }
        // ensure the json data is a string
        if (data['parentContractNumber'] && !(typeof data['parentContractNumber'] === 'string' || data['parentContractNumber'] instanceof String)) {
            throw new Error("Expected the field `parentContractNumber` to be a primitive type in the JSON string but got " + data['parentContractNumber']);
        }

        return true;
    }


}

ContractFinancial.RequiredProperties = ["amendmentDate", "clientId", "contractId", "currency"];

/**
 * Amount of additional credit limit assigned to the contract. Amount expressed in the contract currency.  The field can contain values up to 4 decimal places. A dot is used as a decimal separator. 
 * @member {Number} additionalCreditLimit
 */
ContractFinancial.prototype['additionalCreditLimit'] = undefined;

/**
 * Additional credit limit effective date (YYYY-MM-DD format). Defines when additional credit limit becomes effective. 
 * @member {Date} additionalCreditLimitEffectiveDate
 */
ContractFinancial.prototype['additionalCreditLimitEffectiveDate'] = undefined;

/**
 * Additional credit limit expiration date (YYYY-MM-DD format). Defines when additional credit limit expires. 
 * @member {Date} additionalCreditLimitExpiryDate
 */
ContractFinancial.prototype['additionalCreditLimitExpiryDate'] = undefined;

/**
 * Date and time of the most recent change to the object (YYYY-MM-DDThh:mm:ssZ format). 
 * @member {Date} amendmentDate
 */
ContractFinancial.prototype['amendmentDate'] = undefined;

/**
 * Contract's available amount. Amount expressed in the contract currency.  Presented as a positive amount (without a minus sign) but can be a negative number depending on the CMS configuration.  The field can contain values up to 4 decimal places. A dot is used as a decimal separator. 
 * @member {Number} availableAmount
 */
ContractFinancial.prototype['availableAmount'] = undefined;

/**
 * Contract's balance. Amount expressed in the contract currency.  Presented as a negative amount (with a minus sign) but can be a positive number depending on CMS configuration.  The field can contain values up to 4 decimal places. A dot is used as a decimal separator. 
 * @member {Number} balance
 */
ContractFinancial.prototype['balance'] = undefined;

/**
 * The amount of contract's blocked funds. Amount expressed in the contract currency.  Presented as a positive amount (without a minus sign) but can be a negative number depending on CMS configuration.  The field can contain values up to 4 decimal places. A dot is used as a decimal separator. 
 * @member {Number} blockedAmount
 */
ContractFinancial.prototype['blockedAmount'] = undefined;

/**
 * A unique technical client identifier, generated by the MP's CMS database engine. The identifier is generated when client creation is completed successfully and is returned in a client creation response (`POST /clients`). 
 * @member {Number} clientId
 */
ContractFinancial.prototype['clientId'] = undefined;

/**
 * Contract record id from MP's CMS database. 
 * @member {Number} contractId
 */
ContractFinancial.prototype['contractId'] = undefined;

/**
 * Credit limit assigned to the contract. Amount expressed in the contract currency.  Presented as a positive amount (without a minus sign) but can be a negative number depending on CMS configuration.  The field can contain values up to 4 decimal places. A dot is used as a decimal separator. 
 * @member {Number} creditLimit
 */
ContractFinancial.prototype['creditLimit'] = undefined;

/**
 * Date when the credit limit becomes effective (YYYY-MM-DD format). 
 * @member {Date} creditLimitEffectiveDate
 */
ContractFinancial.prototype['creditLimitEffectiveDate'] = undefined;

/**
 * Currency of the due amount (format according to ISO 4217, alphanumeric code). 
 * @member {String} currency
 */
ContractFinancial.prototype['currency'] = undefined;

/**
 * Currency of the due amount (format according to ISO 4217, numeric code). 
 * @member {String} currencyNumericCode
 */
ContractFinancial.prototype['currencyNumericCode'] = undefined;

/**
 * Due amount for the current billing cycle. Amount expressed in the contract currency.  Presented as a negative amount (with a minus sign) but can be a positive number depending on CMS configuration.  The field can contain values up to 4 decimal places. A dot is used as a decimal separator. 
 * @member {Number} currentDueAmount
 */
ContractFinancial.prototype['currentDueAmount'] = undefined;

/**
 * Delinquency history. 24-digit field showing the cardholder's short delinquency history of the last 24 billing cycles, each digit corresponds to a single billing cycle and may take on these values:   * Digits 1, 2, 3, ... etc. extended by '+' symbol - the value of delinquency level in given cycle.     * 0 - monthly payment was made on time     * 1 - monthly payment was overdue one month     * 2 - monthly payment was overdue for two months, etc.   * '+' symbol - funds on Due balance.   * '_' symbol - there is no history for the billing cycle.   * 'E' symbol - no debt in the billing cycle  The field should be read from right to left. The first character represents the recent billing cycle.  Examples:  1) The value 321+E___________________ means the following:   - 3 - funds are on OVD_03 balance in the current cycle   - 2 - funds were on OVD_02 balance in the previous cycle   - 1 - funds were on OVD_01 balance   - '+' - funds on Due balance   - E - there was no debt in this cycle   - All the rest 19 characters are indicated as '_' since there are only 5 billing cycles in the contract history.  2) Let's have a contract, which has monthly billing and which is 10 months old by today. The contract has a debit transaction right after its creation and has never been paid. We will see the following history: E654321+++______________  That should be read as follows. From right to left: from 10 to 7 months ago the funds were on Due balance (+), 6 months ago funds were on OVD_01 balance (1), 5 months ago funds were on OVD_02 balance (2), ..., 1 month ago funds were on OVD_06 balance (6), the current period is not closed, so it's marked as 'E' - no debt.  Then client repaid and does not have any debts for the next 10 months. The history will change as follows: EEEEEEEEEEE654321+++____ 
 * @member {String} delinquencyHistory
 */
ContractFinancial.prototype['delinquencyHistory'] = undefined;

/**
 * Contract's disputed amount. Amount expressed in the contract currency.  The field can contain values up to 4 decimal places. A dot is used as a decimal separator. 
 * @member {Number} disputeAmount
 */
ContractFinancial.prototype['disputeAmount'] = undefined;

/**
 * Payment due date for the billing cycle (YYYY-MM-DD format).  Date by which cardholder has to repay **Minimum To Pay** amount to avoid excess charges and delinquency processing. This date is usually printed on the cardholder's statement.  The date is calculated by the CMS when the billing cycle is closed, according to Issuer-specific configuration. Possible configuration:   * First day of the cycle (no grace days)   * Number of days (X days) after the first day of the cycle. 
 * @member {Date} dueDate
 */
ContractFinancial.prototype['dueDate'] = undefined;

/**
 * Contract's last billing grace date (YYYY-MM-DD format). 
 * @member {Date} graceDate
 */
ContractFinancial.prototype['graceDate'] = undefined;

/**
 * Amount expressed in the contract currency.  The field can contain values up to 4 decimal places. A dot is used as a decimal separator. 
 * @member {Number} lastPaymentAmount
 */
ContractFinancial.prototype['lastPaymentAmount'] = undefined;

/**
 * Date the last payment was made (YYYY-MM-DD format). 
 * @member {Date} lastPaymentDate
 */
ContractFinancial.prototype['lastPaymentDate'] = undefined;

/**
 * Main contract record id from the CMS database. 
 * @member {Number} mainContractId
 */
ContractFinancial.prototype['mainContractId'] = undefined;

/**
 * The contract number of the main contract. 
 * @member {String} mainContractNumber
 */
ContractFinancial.prototype['mainContractNumber'] = undefined;

/**
 * Contract's overlimit amount.  The field can contain values up to 4 decimal places. A dot is used as a decimal separator. 
 * @member {Number} overlimitAmount
 */
ContractFinancial.prototype['overlimitAmount'] = undefined;

/**
 * Parent contract record id from the CMS database. 
 * @member {Number} parentContractId
 */
ContractFinancial.prototype['parentContractId'] = undefined;

/**
 * The contract number of the parent contract number. 
 * @member {String} parentContractNumber
 */
ContractFinancial.prototype['parentContractNumber'] = undefined;

/**
 * Contract's overdue amount. Amount expressed in the contract currency.  Presented as a negative amount (with a minus sign) but can be a positive number depending on CMS configuration.  The field can contain values up to 4 decimal places. A dot is used as a decimal separator. 
 * @member {Number} pastDueAmount
 */
ContractFinancial.prototype['pastDueAmount'] = undefined;

/**
 * The date on which the delinquency arose (format: YYYY-MM-DD). It is set when funds are transferred from a standard account to a delinquency account.  The field is filled only when a past due balance exists (past due amount is not repaid). The date on which delinquency arises is set in the Past Due Date field when funds are transferred from a standard account to a delinquency account 
 * @member {Date} pastDueDate
 */
ContractFinancial.prototype['pastDueDate'] = undefined;

/**
 * The total number of days is calculated from `pastDueDate`. The field is filled only when a past due balance exists (past due amount is not repaid).  For example, delinquency arose on 01 March. This date is shown in the `pastDueDate` field. On 15 March, the total number of past due days shown in the Past Due Days field is 15 days. 
 * @member {Number} pastDueDays
 */
ContractFinancial.prototype['pastDueDays'] = undefined;

/**
 * Previous credit limit assigned to the contract. Amount expressed in the contract currency.  The field can contain values up to 4 decimal places. A dot is used as a decimal separator. 
 * @member {Number} previousCreditLimit
 */
ContractFinancial.prototype['previousCreditLimit'] = undefined;

/**
 * Previous credit limit effective date. The date when the previous credit limit became effective (YYYY-MM-DD format). 
 * @member {Date} previousCreditLimitEffectiveDate
 */
ContractFinancial.prototype['previousCreditLimitEffectiveDate'] = undefined;

/**
 * Temporary credit limit assigned to the contract. Amount expressed in the contract currency.  The field can contain values up to 4 decimal places. A dot is used as a decimal separator. 
 * @member {Number} temporaryCreditLimit
 */
ContractFinancial.prototype['temporaryCreditLimit'] = undefined;

/**
 * Temporary credit limit effective date. Defines when temporary credit limit becomes effective for the contract (YYYY-MM-DD format). 
 * @member {Date} temporaryCreditLimitEffectiveDate
 */
ContractFinancial.prototype['temporaryCreditLimitEffectiveDate'] = undefined;

/**
 * Temporary credit limit expiration date. Defines when temporary credit limit expires (YYYY-MM-DD format). 
 * @member {Date} temporaryCreditLimitExpiryDate
 */
ContractFinancial.prototype['temporaryCreditLimitExpiryDate'] = undefined;

/**
 * Contract's total due amount. Amount expressed in the contract currency.  Presented as a negative amount (with a minus sign) but can be a positive number depending on CMS configuration.  The field can contain values up to 4 decimal places. A dot is used as a decimal separator. 
 * @member {Number} totalDueAmount
 */
ContractFinancial.prototype['totalDueAmount'] = undefined;






export default ContractFinancial;

